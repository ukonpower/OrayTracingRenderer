!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],t):"object"==typeof exports?exports.OrayTracingRenderer=t(require("THREE")):e.OrayTracingRenderer=t(e.THREE)}(window,(function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(t,n){t.exports=e},function(e,t,n){"use strict";n.r(t),n.d(t,"Renderer",(function(){return s})),n.d(t,"Material",(function(){return c}));var r,i=n(0),a=function(){function e(e,t){this.renderTargets=[],this.renderer=e,this.dataSize=t.clone(),this.uniforms={dataSize:{value:this.dataSize}},this.tempDataLinear=this.createData({minFilter:i.LinearFilter,magFilter:i.LinearFilter}),this.tempDataNear=this.createData({minFilter:i.NearestFilter,magFilter:i.NearestFilter}),this.scene=new i.Scene,this.camera=new i.Camera,this.materials=[],this.mesh=new i.Mesh(new i.PlaneBufferGeometry(2,2)),this.scene.add(this.mesh)}return Object.defineProperty(e.prototype,"isSupported",{get:function(){return this.renderer.extensions.get("OES_texture_float")},enumerable:!1,configurable:!0}),e.prototype.createInitializeTexture=function(){var e=new Float32Array(this.uniforms.dataSize.value.x*this.uniforms.dataSize.value.y*4),t=new i.DataTexture(e,this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,i.RGBAFormat,i.FloatType);return t.needsUpdate=!0,t},e.prototype.createData=function(e,t){var n,r,a={wrapS:i.ClampToEdgeWrapping,wrapT:i.ClampToEdgeWrapping,minFilter:i.NearestFilter,magFilter:i.NearestFilter,format:i.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?i.HalfFloatType:i.FloatType,stencilBuffer:!1,depthBuffer:!1};e&&(e.isDataTexture?(n=e,t&&(r=t)):r=e),r&&(a.wrapS=r.wrapS||a.wrapS,a.wrapT=r.wrapT||a.wrapT,a.minFilter=r.minFilter||a.minFilter,a.magFilter=r.magFilter||a.magFilter,a.format=r.format||a.format,a.type=r.type||a.type,a.stencilBuffer=r.stencilBuffer||a.stencilBuffer,a.depthBuffer=r.depthBuffer||a.depthBuffer);var o=new i.WebGLRenderTarget(this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,a),s={buffer:o};if(this.renderTargets.push(o),n){var l=this.createKernel({fragmentShader:"#define GLSLIFY 1\nuniform sampler2D tex;\nvarying vec2 vUv;\n\nvoid main() {\n    gl_FragColor = texture2D(tex,vUv);\n}"});l.uniforms.tex={value:n},this.compute(l,s)}return s},e.prototype.createKernel=function(e){var t=this.CopyUniforms({},e.uniforms);t=this.CopyUniforms(t,this.uniforms),e.vertexShader=e.vertexShader||"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    gl_Position = vec4( position, 1.0 );\n    vUv = uv;\n}";var n=new i.ShaderMaterial(e);return this.materials.push(n),{material:n,uniforms:t}},e.prototype.compute=function(e,t,n){var r;r=t.buffer.texture.magFilter==i.LinearFilter?this.tempDataLinear:this.tempDataNear,this.mesh.material=e.material;var a=this.renderer.getRenderTarget();this.renderer.setRenderTarget(r.buffer),this.renderer.render(this.scene,n||this.camera),this.swapBuffers(t,r),this.renderer.setRenderTarget(a)},e.prototype.swapBuffers=function(e,t){var n=e.buffer;e.buffer=t.buffer,t.buffer=n},e.prototype.dispose=function(){this.mesh.geometry.dispose();for(var e=0;e<this.materials.length;e++)this.materials[e].dispose();this.scene.remove(this.mesh),this.tempDataLinear.buffer.dispose(),this.tempDataNear.buffer.dispose()},e.prototype.CopyUniforms=function(e,t){if(!e||!t)return e||t;for(var n=Object.keys(t),r=0;r<n.length;r++)e[n[r]]||(e[n[r]]=t[n[r]]);return e},e.prototype.resizeData=function(e){this.dataSize.copy(e);for(var t=0;t<this.renderTargets.length;t++){this.renderTargets[t].setSize(e.x,e.y)}},e}(),o=(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),s=function(e){function t(t,n){var r=this,a=n.clone();return(r=e.call(this,t,a)||this).commonUniforms=i.UniformsUtils.merge([{backBuffer:{value:null},albedoBuffer:{value:null},emissionBuffer:{value:null},materialBuffer:{value:null},normalBuffer:{value:null},depthBuffer:{value:null},backNormalBuffer:{value:null},backDepthBuffer:{value:null},renderResult:{value:null},cameraMatrixWorld:{value:null},cameraMatrixWorldInverse:{value:null},cameraProjectionMatrixInverse:{value:null},cameraProjectionMatrix:{value:null},envMap:{value:null},background:{value:new i.Vector3(1,1,1)},frame:{value:0},dofBlurRadius:{value:0},focalDistance:{value:10}},i.UniformsLib.lights]),r.init(),r}return o(t,e),t.prototype.init=function(){this.lights=new i.Object3D,this.scene.add(this.lights),this.renderKernel=this.createKernel({fragmentShader:"#define GLSLIFY 1\nuniform mat4 cameraMatrixWorld;\nuniform mat4 cameraMatrixWorldInverse;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraProjectionMatrixInverse;\nuniform mat4 projectionMatrix;\n\nuniform float focalDistance;\nuniform float dofBlurRadius;\n\nuniform float time;\nuniform float frame;\n\nuniform sampler2D backBuffer;\nuniform sampler2D albedoBuffer;\nuniform sampler2D emissionBuffer;\nuniform sampler2D materialBuffer;\nuniform sampler2D normalBuffer;\nuniform sampler2D depthBuffer;\nuniform sampler2D backNormalBuffer;\nuniform sampler2D backDepthBuffer;\nuniform samplerCube envMap;\n\nvarying vec2 vUv;\n\nfloat random(vec2 p){\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define MAX_BOUNCE 5\n#define MAX_STEP 70\n#define RAY_DISTANCE 0.7\n#define INF 1e+10\n#define EPS 1e-5\n\n#include <common>\n#include <lights_pars_begin>\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Material {\n\tvec3 albedo;\n\tvec3 emission;\n\tfloat roughness;\n\tfloat metalness;\n};\n\nstruct Intersection {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 nextPosition;\n\tbool hit;\n\tfloat distance;\n\tMaterial material;\n};\n\nstruct Sphere {\n\tvec3 position;\n\tfloat radius;\n\tMaterial material;\n};\n\nstruct Plane {\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nvec3 random3D( vec2 p, float seed ) {\n\n\treturn vec3(\n\t\trandom( p + seed ),\n\t\trandom( p + seed + 100.0 ),\n\t\trandom( p + seed + 303.2)\n\t);\n\t\n}\n\n//http://project-asura.com/blog/archives/3124\nvec3 ggx( Intersection intersection, Ray ray, vec2 noise )\n{\n\n\tvec3 normal = intersection.normal;\n\tfloat roughness = intersection.material.roughness;\n\n    float a = roughness * roughness;\n\n    float phi = 2.0 * PI * noise.x;\n    float cosTheta = sqrt( ( 1.0  - noise.y ) / ( 1.0  + ( a * a - 1.0 ) * noise.y ) );\n    float sinTheta = sqrt( 1.0  - cosTheta * cosTheta );\n    \n    vec3 H;\n    H.x = sinTheta * cos( phi );\n    H.y = sinTheta * sin( phi );\n    H.z = cosTheta;\n    \n    vec3 upVector = abs( normal.z ) < 0.999 ? vec3( 0, 0, 1 ) : vec3( 1, 0, 0 );\n    vec3 tangentX = normalize( cross( upVector , normal ) );\n    vec3 tangentY = cross( normal, tangentX );\n\n    return reflect( ray.direction, tangentX * H.x + tangentY * H.y + normal * H.z );\n\n}\n\nfloat fresnel( float f0, float dVH ) {\n\t\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - dVH, 2.0 );\n\n}\n\nvec3 diffuse( Intersection intersection, vec2 noise ) {\n\n\tvec3 normal = intersection.normal;\n\t\n\tfloat r = sqrt( noise.x );\n\tfloat theta = PI2 * noise.y;\n\n\tvec3 tDir = vec3( r * cos( theta ), r * sin( theta ), sqrt( 1.0 - noise.x ) );\n\tvec3 tangent = normalize( cross( normal, abs( normal.x ) > EPS ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ) ) );\n\tvec3 binormal = cross( tangent, normal );\n\t\n\treturn tangent * tDir.x + binormal * tDir.y + normal * tDir.z;\n\n}\n\nbool checkIntersect( inout vec3 startPos, inout vec3 nextPos ) {\n\n\treturn false;\n\t\n}\n\nvec3 getScreenPos( vec3 p ) {\n\n\tvec4 clip = cameraProjectionMatrix * vec4( p, 1.0 );\n\treturn ( clip / clip.w ).xyz;\n\n}\n\nint shootRay( inout Intersection intersection, inout Ray ray, int bounce ) {\n\n\tintersection.hit = false;\n\tintersection.distance = INF;\n\tintersection.position = ray.origin;\n\n\tfor( int i = 0; i < MAX_STEP; i++ ) {\n\t\t\n\t\tintersection.nextPosition = intersection.position + ray.direction * RAY_DISTANCE;\n\t\tvec3 startPosClip;\n\t\tvec3 nextPosClip;\n\t\tvec2 nextPosUV;\n\t\tvec4 texDepthFront;\n\t\tvec4 texDepthBack;\n\t\tfloat texDepthFrontClip;\n\t\tfloat texDepthBackClip;\n\n\t\tstartPosClip = getScreenPos( intersection.position );\n\t\tnextPosClip = getScreenPos( intersection.nextPosition );\n\t\t\n\t\tnextPosUV = nextPosClip.xy * 0.5 + 0.5;\n\n\t\ttexDepthFront = texture2D( depthBuffer, nextPosUV );\n\t\ttexDepthFrontClip = texDepthFront.x / texDepthFront.w;\n\n\t\ttexDepthBack = texture2D( backDepthBuffer, nextPosUV );\n\t\ttexDepthBackClip = texDepthBack.x / texDepthBack.w;\n\n\t\tif(\n\t\t\t( nextPosClip.z >= texDepthFrontClip && startPosClip.z <= texDepthBackClip ) && texDepthFrontClip != 0.0 \n\t\t) {\n\n\t\t\tintersection.hit = true;\n\t\t\tintersection.nextPosition = ( intersection.position + intersection.nextPosition ) / 2.0;\n\n\t\t}\n\n\t\tif( intersection.hit ) {\n\n\t\t\tMaterial mat;\n\t\t\tmat.albedo = texture2D( albedoBuffer, nextPosUV ).xyz;\n\t\t\tmat.emission = texture2D( emissionBuffer, nextPosUV ).xyz;\n\t\t\t\n\t\t\tvec4 rmTex = texture2D( materialBuffer, nextPosUV );\n\t\t\tmat.roughness = rmTex.y;\n\t\t\tmat.metalness = rmTex.z;\n\t\t\tintersection.material = mat;\n\t\t\tintersection.normal = normalize( texture2D( normalBuffer, nextPosUV ).xyz * 2.0 - 1.0 );\n\t\t\tintersection.position = ( cameraProjectionMatrixInverse * vec4( (nextPosUV * 2.0 - 1.0) * texDepthFront.w, texDepthFrontClip, texDepthFront.w ) ).xyz;\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\n\t\tintersection.position = intersection.nextPosition;\n\n\t}\n\n\tif( intersection.hit ) {\n\n\t\tfloat seed =  frame * 0.001 + float( bounce );\n\t\tvec2 noise = vec2( random( vUv + sin( seed ) ), random( vUv - cos( seed ) ) );\n\n\t\tray.origin = intersection.position;\n\n\t\tvec3 v = normalize( - intersection.position );\n\t\tfloat dvh = dot( v, intersection.normal );\n\n\t\tfloat rnd = random( vUv * 10.0 + sin( time + float( frame ) + seed ) );\n\t\tfloat specular = fresnel( 0.04 + intersection.material.metalness * 0.96, dvh );\n\n\t\tif( rnd > specular ) {\n\t\t\t\n\t\t\tray.direction = diffuse( intersection, noise );\n\t\t\t\n\t\t\treturn 0;\n\t\t\t\n\t\t} else {\n\n\t\t\tray.direction = ggx( intersection, ray, noise );\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t} else {\n\n\t\tvec4 rayDir = vec4( ray.direction, 1.0 ) * cameraMatrixWorldInverse;\n\t\tintersection.material.emission = textureCube( envMap, rayDir.xyz, 0.0 ).xyz * 2.5;\n\n\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\tDirectionalLight dirLight = directionalLights[ i ];\n\t\t\t\tintersection.material.emission += smoothstep( 0.95, 1.0, dot(dirLight.direction, ray.direction) ) * 20.0 * dirLight.color;\n\t\t\t\t\n\t\t\t}\n\n\t\t#endif\n\n\t}\n\n\treturn 0;\n\n}\n\nvec3 radiance( inout Ray ray ) {\n\n\tIntersection intersection;\n\n\tvec3 acc = vec3( 0.0 );\n\tvec3 ref = vec3( 1.0 );\n\n\tfor ( int i = 0; i < MAX_BOUNCE; i++ ) {\n\n\t\tint type = shootRay( intersection, ray, i );\n\t\tMaterial mat = intersection.material;\n\n\t\tvec3 col;\n\n\t\tif ( type > 0 ) {\n\n\t\t\t//ggx\n\t\t\tcol = mix( vec3( 1.0 ), mat.albedo, mat.metalness );\n\n\t\t} else {\n\t\t\t\n\t\t\t//diffuse\n\t\t\tcol = mix( vec3( 0.0 ), mat.albedo, 1.0 - mat.metalness );\n\n\t\t}\n\n\t\tacc += ref * mat.emission;\n\t\tref *= col;\n\n\t\tif( !intersection.hit ) {\n\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\treturn acc;\n\t\n}\n\nvoid main( void ) {\n\t\n\tvec4 befTex = texture2D( backBuffer, vUv ) * min( frame, 1.0 ) ;\n\n\tRay ray;\n\tray.origin = vec3( 0.0, 0.0, 0.0 );\n\tray.direction = ( cameraProjectionMatrixInverse * vec4( vUv * 2.0 - 1.0, 1.0, 1.0 ) ).xyz;\n\tray.direction = normalize( ray.direction );\n\n\t//random\n\tfloat r1 = random( vUv + sin( frame * 0.1 ) );\n\tfloat r2 = random( vUv - cos( frame * 0.1 ) );\n\n\t//anti-aliasing\n\t// ray.direction.xy += vec2( r1 * 2.0 - 1.0 , r2 * 2.0 - 1.0 ) * 0.001;\n\n\t//DOF\n\tfloat t1 = PI2 * r1;\n\tfloat t2 = sqrt( r2 );\n\tvec3 offset = vec3(cos(t1)*t2, sin(t1)*t2, 0.0) * (dofBlurRadius + 0.0);\n\tvec3 p = ray.origin + ray.direction * (focalDistance);\n\tray.origin += offset;\n\tray.direction = normalize( p - ray.origin );\n\t\n\tvec4 o = vec4( ( befTex.xyz + radiance( ray ) ) , 1.0 );\n\n\tgl_FragColor = o;\n\t\n}",uniforms:this.commonUniforms,lights:!0}),this.renderResultData=this.createData(),this.createRenderTargets(),this.renderScene=new i.Scene,this.screen=new i.Mesh(new i.PlaneBufferGeometry(2,2),new i.ShaderMaterial({vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n\tvec3 pos = position;\n\tgl_Position = vec4( pos, 1.0 );\n\n\tvUv = vec2( uv.x, uv.y );\n\n}",fragmentShader:"#define GLSLIFY 1\nuniform float frame;\nuniform sampler2D renderResult;\n\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n\tvec3 color = texture2D( renderResult, vUv ).xyz;\n\tcolor /= (frame + 1.0);\n\n\tgl_FragColor = vec4( color, 1.0 );\n\n}",uniforms:this.commonUniforms})),this.renderScene.add(this.screen)},Object.defineProperty(t.prototype,"focalDistance",{set:function(e){this.commonUniforms.focalDistance.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dofBlurRadius",{set:function(e){this.commonUniforms.dofBlurRadius.value=e},enumerable:!1,configurable:!0}),t.prototype.createRenderTargets=function(){this.orayRenderTargets={albedo:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),emission:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.HalfFloatType}),material:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),normal:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),depth:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backNormal:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backDepth:new i.WebGLRenderTarget(0,0,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType})},this.resize(this.dataSize)},t.prototype.updateLights=function(e){for(var t=this,n=this.lights.children.length-1;n>=0;n--)this.lights.remove(this.lights.children[n]);e.traverse((function(e){if(e.isLight){var n=e.getWorldPosition(new i.Vector3),r=e.getWorldQuaternion(new i.Quaternion),a=e.clone();a.position.copy(n),a.quaternion.copy(r),t.lights.add(a)}}))},t.prototype.render=function(e,t){var n=this.renderer.getRenderTarget();if(0==this.commonUniforms.frame.value){var r=e.background;e.background=null;for(var i=Object.keys(this.orayRenderTargets),a=function(n){e.traverse((function(e){e.isMesh&&e.material.isMaterial&&e.material.setRenderType(n)})),o.renderer.setRenderTarget(o.orayRenderTargets[i[n]]),o.renderer.render(e,t),o.commonUniforms[i[n]+"Buffer"].value=o.orayRenderTargets[i[n]].texture},o=this,s=0;s<i.length;s++)a(s);e.background=r,this.updateLights(e)}this.renderer.setRenderTarget(n),this.commonUniforms.backBuffer.value=this.renderResultData.buffer.texture,this.commonUniforms.cameraMatrixWorld.value=t.matrixWorld,this.commonUniforms.cameraMatrixWorldInverse.value=t.matrixWorldInverse,this.commonUniforms.cameraProjectionMatrix.value=t.projectionMatrix,this.commonUniforms.cameraProjectionMatrixInverse.value=t.projectionMatrixInverse,e.background&&(e.background.isTexture?this.commonUniforms.envMap.value=e.background:this.commonUniforms.background.value.copy(e.background)),this.compute(this.renderKernel,this.renderResultData,t),this.commonUniforms.renderResult.value=this.renderResultData.buffer.texture,this.renderer.render(this.renderScene,t),this.commonUniforms.frame.value++},t.prototype.resetFrame=function(){this.commonUniforms.frame.value=0},t.prototype.resize=function(e){this.resizeData(e),this.orayRenderTargets.albedo.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.emission.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.material.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.normal.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.depth.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.backNormal.setSize(this.dataSize.x,this.dataSize.y),this.orayRenderTargets.backDepth.setSize(this.dataSize.x,this.dataSize.y)},t}(a),l=function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),c=function(e){function t(t){(t=t||{}).fragmentShader=t.fragmentShader||"#define GLSLIFY 1\nuniform float renderType;\nuniform vec3 albedo;\nuniform vec3 emission;\nuniform float roughness;\nuniform float metalness;\nuniform mat3 normalMatrix;\n\nuniform sampler2D albedoMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metalnessMap;\nuniform sampler2D normalMap;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDepth;\nvarying vec4 vPos;\nvarying vec3 vViewPosition;\n\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See vec4(0.6,0.6,0.5333333333333333,0.5333333333333333)\n\n\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\tvec2 st0 = dFdx( vUv.st );\n\tvec2 st1 = dFdy( vUv.st );\n\n\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\tvec3 N = normalize( surf_norm );\n\n\tmat3 tsn = mat3( S, T, N );\n\n\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\treturn normalize( tsn * mapN );\n\n}\n\nvoid main( void ) {\n\n\tif( renderType == 0.0 ) {\n\n\t\t//albedo\t\t\n\t\t#ifdef USE_ALBEDOMAP\n\n\t\t\tgl_FragColor = texture2D( albedoMap, vUv );\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor = vec4( albedo, 0.0 );\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 1.0 ) {\n\n\t\t//emission\n\t\tgl_FragColor = vec4( emission, 0.0 );\n\t\t\n\t} else if ( renderType == 2.0 ) {\n\n\t\t#ifdef USE_ROUGHNESSMAP\n\n\t\t\tgl_FragColor.y = texture2D( roughnessMap, vUv ).y * roughness;\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor.y = roughness;\n\t\t\t\n\t\t#endif\n\n\t\t#ifdef USE_METALNESSMAP\n\n\t\t\tgl_FragColor.z = texture2D( metalnessMap, vUv ).z * metalness;\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor.z = metalness;\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 3.0 || renderType == 5.0 ) {\n\n\t\t//normal\n\n\t\t#ifdef USE_NORMALMAP\n\t\t\tvec3 normal = vNormal; \n\t\t\tnormal = normalize( normalMatrix * normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= 1.0;\n\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t\t\tgl_FragColor = vec4( normal * 0.5 + 0.5 , 0.0 );\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor = vec4( vNormal * 0.5 + 0.5, 0.0 );\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 4.0 || renderType == 6.0 ) {\n\n\t\t//depth\n\t\t// gl_FragColor = vec4( vec3( ( ( vPos.z / vPos.w ) + 1.0 ) / 2.0 ), vPos.w  );\n\t\tgl_FragColor = vec4( vec3( vPos.z ), vPos.w  );\n\t\t\n\t}\n\n\t\n}",t.vertexShader=t.vertexShader||"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDepth;\nvarying vec4 vPos;\nvarying vec3 vViewPosition;\n\nvoid main( void ) {\n\n\tvec3 pos = position;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\tvUv = uv;\n\tvNormal = normal;\n\tvPos = gl_Position;\n\tvViewPosition = - mvPosition.xyz;\n\n}",t.uniforms=t.uniforms||{},t.uniforms.renderType&&console.warn('"renderType" uniform cannnot be used.'),t.uniforms.renderType={value:0};var n=t.baseMaterial&&null==t.baseMaterial.length&&t.baseMaterial,r=t.albedoMap||n&&n.map,a=t.roughnessMap||n&&n.roughnessMap,o=t.metalnessMap||n&&n.metalnessMap,s=t.normalMap||n&&n.normalMap,l=t.emissionMap&&n&&n.emissiveMap;return t.defines={USE_ALBEDOMAP:null!=r&&null==t.albedo,USE_ROUGHNESSMAP:null!=a&&null==t.roughness,USE_METALNESSMAP:null!=o&&null==t.metalness,USE_NORMALMAP:null!=s,USE_EMISSIONMAP:null!=l&&null==t.emission},t.uniforms.albedo={value:t.albedo||(n?n.color:new i.Vector3(0,0,0))},t.uniforms.emission={value:t.emission||(n?n.emissive:new i.Vector3(0,0,0))},t.uniforms.roughness={value:t.roughness||(n?n.roughness:0)},t.uniforms.metalness={value:t.metalness||(n?n.metalness:0)},t.uniforms.albedoMap={value:r},t.uniforms.emissionMap={value:l},t.uniforms.roughnessMap={value:a},t.uniforms.metalnessMap={value:o},t.uniforms.normalMap={value:s},t.extensions?t.extensions.derivatives=!0:t.extensions={derivatives:!0},delete t.baseMaterial,delete t.albedo,delete t.roughness,delete t.metalness,delete t.emission,delete t.albedoMap,delete t.roughnessMap,delete t.metalnessMap,delete t.emissionMap,e.call(this,t)||this}return l(t,e),Object.defineProperty(t.prototype,"albedo",{set:function(e){this.uniforms.albedo.value.copy(e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"emission",{set:function(e){this.uniforms.emission.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"roughness",{set:function(e){this.uniforms.roughness.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"metalness",{set:function(e){this.uniforms.metalness.value=e},enumerable:!1,configurable:!0}),t.prototype.setRenderType=function(e){this.uniforms.renderType.value=e,this.side=e>=5?i.BackSide:i.FrontSide},Object.defineProperty(t.prototype,"isOrayTracingMaterial",{get:function(){return!0},enumerable:!1,configurable:!0}),t}(i.ShaderMaterial)}])}));