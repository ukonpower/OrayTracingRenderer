!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],t):"object"==typeof exports?exports.OrayTracingRenderer=t(require("THREE")):e.OrayTracingRenderer=t(e.THREE)}(window,(function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(t,n){t.exports=e},function(e,t,n){"use strict";n.r(t),n.d(t,"Renderer",(function(){return s})),n.d(t,"Material",(function(){return m}));var r,i=n(0),o=function(){function e(e,t){this.renderer=e,this.dataSize=t.clone(),this.uniforms={dataSize:{value:t.clone()}},this.tempDataLinear=this.createData({minFilter:i.LinearFilter,magFilter:i.LinearFilter}),this.tempDataNear=this.createData({minFilter:i.NearestFilter,magFilter:i.NearestFilter}),this.scene=new i.Scene,this.camera=new i.Camera,this.materials=[],this.mesh=new i.Mesh(new i.PlaneBufferGeometry(2,2)),this.scene.add(this.mesh)}return Object.defineProperty(e.prototype,"isSupported",{get:function(){return this.renderer.extensions.get("OES_texture_float")},enumerable:!1,configurable:!0}),e.prototype.createInitializeTexture=function(){var e=new Float32Array(this.uniforms.dataSize.value.x*this.uniforms.dataSize.value.y*4),t=new i.DataTexture(e,this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,i.RGBAFormat,i.FloatType);return t.needsUpdate=!0,t},e.prototype.createData=function(e,t){var n,r,o={wrapS:i.ClampToEdgeWrapping,wrapT:i.ClampToEdgeWrapping,minFilter:i.NearestFilter,magFilter:i.NearestFilter,format:i.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?i.HalfFloatType:i.FloatType,stencilBuffer:!1,depthBuffer:!1};e&&(e.isDataTexture?(n=e,t&&(r=t)):r=e),r&&(o.wrapS=r.wrapS||o.wrapS,o.wrapT=r.wrapT||o.wrapT,o.minFilter=r.minFilter||o.minFilter,o.magFilter=r.magFilter||o.magFilter,o.format=r.format||o.format,o.type=r.type||o.type,o.stencilBuffer=r.stencilBuffer||o.stencilBuffer,o.depthBuffer=r.depthBuffer||o.depthBuffer);var a={buffer:new i.WebGLRenderTarget(this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,o)};if(n){var s=this.createKernel("#define GLSLIFY 1\nuniform sampler2D tex;\nvarying vec2 vUv;\n\nvoid main() {\n    gl_FragColor = texture2D(tex,vUv);\n}");s.uniforms.tex={value:n},this.compute(s,a)}return a},e.prototype.createKernel=function(e,t){var n=this.CopyUniforms({},t);n=this.CopyUniforms(n,this.uniforms);var r=new i.ShaderMaterial({vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    gl_Position = vec4( position, 1.0 );\n    vUv = uv;\n}",fragmentShader:e,uniforms:n});return this.materials.push(r),{material:r,uniforms:n}},e.prototype.compute=function(e,t,n){var r;r=t.buffer.texture.magFilter==i.LinearFilter?this.tempDataLinear:this.tempDataNear,this.mesh.material=e.material;var o=this.renderer.getRenderTarget();this.renderer.setRenderTarget(r.buffer),this.renderer.render(this.scene,n||this.camera),this.swapBuffers(t,r),this.renderer.setRenderTarget(o)},e.prototype.swapBuffers=function(e,t){var n=e.buffer;e.buffer=t.buffer,t.buffer=n},e.prototype.dispose=function(){this.mesh.geometry.dispose();for(var e=0;e<this.materials.length;e++)this.materials[e].dispose();this.scene.remove(this.mesh),this.tempDataLinear.buffer.dispose(),this.tempDataNear.buffer.dispose()},e.prototype.CopyUniforms=function(e,t){if(!e||!t)return e||t;for(var n=Object.keys(t),r=0;r<n.length;r++)e[n[r]]||(e[n[r]]=t[n[r]]);return e},e}(),a=(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),s=function(e){function t(t,n){var r=this,o=n.clone();return(r=e.call(this,t,o)||this).commonUniforms={backBuffer:{value:null},albedoBuffer:{value:null},emissionBuffer:{value:null},materialBuffer:{value:null},normalBuffer:{value:null},depthBuffer:{value:null},backNormalBuffer:{value:null},backDepthBuffer:{value:null},renderResult:{value:null},cameraMatrixWorld:{value:null},cameraMatrixWorldInverse:{value:null},cameraProjectionMatrixInverse:{value:null},cameraProjectionMatrix:{value:null},envMap:{value:null},background:{value:new i.Vector3(1,1,1)},frame:{value:0}},r.init(),r}return a(t,e),t.prototype.init=function(){this.renderKernel=this.createKernel("#define GLSLIFY 1\nuniform vec2 dataSize;\nuniform mat4 cameraMatrixWorld;\nuniform mat4 cameraMatrixWorldInverse;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraProjectionMatrixInverse;\nuniform mat4 projectionMatrix;\n\nuniform float roughness;\nuniform float metalness;\nuniform vec3 albedo;\n\nuniform float time;\nuniform float frame;\n\nuniform sampler2D backBuffer;\nuniform sampler2D albedoBuffer;\nuniform sampler2D emissionBuffer;\nuniform sampler2D materialBuffer;\nuniform sampler2D normalBuffer;\nuniform sampler2D depthBuffer;\nuniform sampler2D backNormalBuffer;\nuniform sampler2D backDepthBuffer;\nuniform samplerCube envMap;\n\nbool debug = false;\nvarying vec2 vUv;\n\n#define MAX_BOUNCE 8\n\n#define PI 3.14159265359\n#define TPI 6.28318530718\n#define HPI 1.57079632679\n\nfloat random(vec2 p){\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float INF = 1e+10;\nconst float EPS = 1e-5;\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Material {\n\tvec3 albedo;\n\tvec3 emission;\n\tfloat roughness;\n\tfloat metalness;\n};\n\nstruct Intersection {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 nextPosition;\n\tbool hit;\n\tfloat distance;\n\tMaterial material;\n};\n\nstruct Sphere {\n\tvec3 position;\n\tfloat radius;\n\tMaterial material;\n};\n\nstruct Plane {\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nvec3 random3D( vec2 p, float seed ) {\n\n\treturn vec3(\n\t\trandom( p + seed ),\n\t\trandom( p + seed + 100.0 ),\n\t\trandom( p + seed + 303.2)\n\t);\n\t\n}\n\n//http://project-asura.com/blog/archives/3124\nvec3 ggx( Intersection intersection, Ray ray, vec2 noise )\n{\n\n\tvec3 normal = intersection.normal;\n\tfloat roughness = intersection.material.roughness;\n\n    float a = roughness * roughness;\n\n    float phi = 2.0 * PI * noise.x;\n    float cosTheta = sqrt( ( 1.0  - noise.y ) / ( 1.0  + ( a * a - 1.0 ) * noise.y ) );\n    float sinTheta = sqrt( 1.0  - cosTheta * cosTheta );\n    \n    vec3 H;\n    H.x = sinTheta * cos( phi );\n    H.y = sinTheta * sin( phi );\n    H.z = cosTheta;\n    \n    vec3 upVector = abs( normal.z ) < 0.999 ? vec3( 0, 0, 1 ) : vec3( 1, 0, 0 );\n    vec3 tangentX = normalize( cross( upVector , normal ) );\n    vec3 tangentY = cross( normal, tangentX );\n\n    return reflect( ray.direction, tangentX * H.x + tangentY * H.y + normal * H.z );\n\n}\n\nvec3 diffuse( Intersection intersection, vec2 noise ) {\n\n\tvec3 normal = intersection.normal;\n\t\n\tfloat r = sqrt( noise.x );\n\tfloat theta = TPI * noise.y;\n\n\tvec3 tDir = vec3( r * cos( theta ), r * sin( theta ), sqrt( 1.0 - noise.x ) );\n\tvec3 tangent = normalize( cross( normal, abs( normal.x ) > EPS ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ) ) );\n\tvec3 binormal = cross( tangent, normal );\n\t\n\treturn tangent * tDir.x + binormal * tDir.y + normal * tDir.z;\n\n}\n\n#define MAX_STEP 100\n\nbool checkIntersect( inout vec3 startPos, inout vec3 nextPos ) {\n\n\treturn false;\n\t\n}\n\nvec3 getScreenPos( vec3 p ) {\n\n\tvec4 clip = cameraProjectionMatrix * vec4( p, 1.0 );\n\treturn ( clip / clip.w ).xyz;\n\n}\n\nint shootRay( inout Intersection intersection, inout Ray ray, int bounce ) {\n\n\tintersection.hit = false;\n\tintersection.distance = INF;\n\tintersection.position = ray.origin;\n\n\tfor( int i = 0; i < MAX_STEP; i++ ) {\n\t\t\n\t\tintersection.nextPosition = intersection.position + ray.direction * 0.5;\n\t\tvec3 startPosClip;\n\t\tvec3 nextPosClip;\n\t\tvec2 nextPosUV;\n\t\tvec4 texDepthFront;\n\t\tvec4 texDepthBack;\n\t\tfloat texDepthFrontClip;\n\t\tfloat texDepthBackClip;\n\n\t\tfor( int j = 0; j < 1; j ++ ) {\n\n\t\t\tstartPosClip = getScreenPos( intersection.position );\n\t\t\tnextPosClip = getScreenPos( intersection.nextPosition );\n\t\t\t\n\t\t\tnextPosUV = nextPosClip.xy * 0.5 + 0.5;\n\n\t\t\ttexDepthFront = texture2D( depthBuffer, nextPosUV );\n\t\t\ttexDepthFrontClip = texDepthFront.x / texDepthFront.w;\n\n\t\t\ttexDepthBack = texture2D( backDepthBuffer, nextPosUV );\n\t\t\ttexDepthBackClip = texDepthBack.x / texDepthBack.w;\n\n\t\t\tif(\n\t\t\t\t( nextPosClip.z >= texDepthFrontClip && startPosClip.z <= texDepthBackClip ) && texDepthFrontClip != 0.0 \n\t\t\t) {\n\n\t\t\t\tintersection.hit = true;\n\t\t\t\tintersection.nextPosition = ( intersection.position + intersection.nextPosition ) / 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tif( j == 0 ) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t} else {\n\n\t\t\t\t\tvec3 nextPos = intersection.nextPosition + ( intersection.nextPosition - intersection.position ) / 2.0;\n\t\t\t\t\tintersection.position = intersection.nextPosition;\n\t\t\t\t\tintersection.nextPosition = nextPos;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\n\t\t}\n\n\t\tif( intersection.hit ) {\n\n\t\t\tMaterial mat;\n\t\t\tmat.albedo = texture2D( albedoBuffer, nextPosUV ).xyz;\n\t\t\tmat.emission = texture2D( emissionBuffer, nextPosUV ).xyz;\n\t\t\t\n\t\t\tvec4 rmTex = texture2D( materialBuffer, nextPosUV );\n\t\t\tmat.roughness = rmTex.y;\n\t\t\tmat.metalness = rmTex.z;\n\t\t\tintersection.material = mat;\n\t\t\tintersection.normal = normalize( texture2D( normalBuffer, nextPosUV ).xyz * 2.0 - 1.0 );\n\t\t\tintersection.position = ( cameraProjectionMatrixInverse * vec4( (nextPosUV * 2.0 - 1.0) * texDepthFront.w, texDepthFrontClip, texDepthFront.w ) ).xyz;\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\n\t\tintersection.position = intersection.nextPosition;\n\n\t}\n\n\tif( intersection.hit ) {\n\n\t\tfloat seed =  frame * 0.001 + float( bounce );\n\t\tvec2 noise = vec2( random( vUv + sin( seed ) ), random( vUv - cos( seed ) ) );\n\n\t\tray.origin = intersection.position;\n\n\t\tif( random( vUv * 10.0 + sin( time + float( frame ) + seed ) ) > 0.5 * ( 1.0 - intersection.material.roughness * ( 1.0 - intersection.material.metalness )  ) + intersection.material.metalness * 0.5 ) {\n\t\t\t\n\t\t\tray.direction = diffuse( intersection, noise );\n\t\t\t\n\t\t\treturn 0;\n\t\t\t\n\t\t} else {\n\n\t\t\tray.direction = ggx( intersection, ray, noise );\n\t\t\treturn 1;\n\n\t\t}\n\n\t} else {\n\n\t\tvec4 rayDir = vec4( ray.direction, 1.0 ) * cameraMatrixWorldInverse;\n\t\tintersection.material.emission = textureCube( envMap, rayDir.xyz, 0.0 ).xyz * 2.5;\n\n\t}\n\n\treturn 0;\n\n}\n\nvec3 radiance( inout Ray ray ) {\n\n\tIntersection intersection;\n\n\tfloat memMetalness[MAX_BOUNCE];\n\tvec3 memAlbedo[MAX_BOUNCE];\n\tvec3 memEmission[MAX_BOUNCE];\n\tint memDir[MAX_BOUNCE];\n\n\tint bounce;\n\t\n\tfor ( int i = 0; i < MAX_BOUNCE; i++ ) {\n\n\t\tmemDir[i] = shootRay( intersection, ray, i );\n\t\tmemAlbedo[i] = intersection.material.albedo;\n\t\tmemEmission[i] = intersection.material.emission;\n\t\tmemMetalness[i] = intersection.material.metalness;\n\n\t\tif( !intersection.hit ) {\n\n\t\t\tbounce = i;\n\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\n\tvec3 emission = memEmission[ MAX_BOUNCE - 1 ];\n\tvec3 col;\n\n\tfor ( int i = MAX_BOUNCE -1; i >= 0 ; i-- ) {\n\n\t\tif ( memDir[ i ] > 0 ) {\n\n\t\t\t//ggx\n\t\t\tcol *= mix( vec3( 1.0 ), memAlbedo[i], memMetalness[ i ] );\n\n\t\t} else {\n\t\t\t\n\t\t\t//diffuse\n\t\t\tcol *= mix( vec3( 0.0 ), memAlbedo[i], 1.0 - memMetalness[ i ] );\n\n\t\t}\n\n\t\tcol += memEmission[ i ];\n\n\t}\n\n\treturn col;\n\t\n\t\n}\n\nvoid main( void ) {\n\t\n\tvec4 befTex = texture2D( backBuffer, vUv ) * min( frame, 1.0 ) ;\n\n\tRay ray;\n\t// ray.origin = cameraPosition;\n\t// ray.direction = ( cameraProjectionMatrixInverse * vec4( vUv * 2.0 - 1.0, 1.0, 1.0 ) ).xyz;\n\t\n\tray.origin = vec3( 0.0, 0.0, 0.0 );\n\tray.direction = ( cameraProjectionMatrixInverse * vec4( vUv * 2.0 - 1.0, 1.0, 1.0 ) ).xyz;\n\tray.direction.xy += vec2( random( vUv + time ) * 2.0 - 1.0 , random( vUv - time ) * 2.0 - 1.0 ) / max( dataSize.y,dataSize.x );\n\tray.direction = normalize( ray.direction );\n\n\tvec4 o = vec4( ( befTex.xyz + radiance( ray ) ) , 1.0 );\n\tgl_FragColor = o;\n\n}",this.commonUniforms),this.renderResultData=this.createData(),this.orayRenderTargets={albedo:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),emission:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.HalfFloatType}),material:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),normal:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),depth:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backNormal:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backDepth:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType})},this.renderScene=new i.Scene,this.screen=new i.Mesh(new i.PlaneBufferGeometry(2,2),new i.ShaderMaterial({vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n\tvec3 pos = position;\n\tgl_Position = vec4( pos, 1.0 );\n\n\tvUv = vec2( uv.x, uv.y );\n\n}",fragmentShader:"#define GLSLIFY 1\nuniform float frame;\nuniform sampler2D renderResult;\n\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n\tvec3 color = texture2D( renderResult, vUv ).xyz;\n\tcolor /= (frame + 1.0);\n\n\tgl_FragColor = vec4( color, 1.0 );\n\n}",uniforms:this.commonUniforms})),this.renderScene.add(this.screen)},t.prototype.render=function(e,t){var n=this.renderer.getRenderTarget();if(0==this.commonUniforms.frame.value){var r=e.background;e.background=null;for(var i=Object.keys(this.orayRenderTargets),o=function(n){e.traverse((function(e){e.isMesh&&e.material.isMaterial&&e.material.setRenderType(n)})),a.renderer.setRenderTarget(a.orayRenderTargets[i[n]]),a.renderer.render(e,t),a.commonUniforms[i[n]+"Buffer"].value=a.orayRenderTargets[i[n]].texture},a=this,s=0;s<i.length;s++)o(s);e.background=r}this.renderer.setRenderTarget(n),this.commonUniforms.backBuffer.value=this.renderResultData.buffer.texture,this.commonUniforms.cameraMatrixWorld.value=t.matrixWorld,this.commonUniforms.cameraMatrixWorldInverse.value=t.matrixWorldInverse,this.commonUniforms.cameraProjectionMatrix.value=t.projectionMatrix,this.commonUniforms.cameraProjectionMatrixInverse.value=t.projectionMatrixInverse,e.background&&(e.background.isTexture?this.commonUniforms.envMap.value=e.background:this.commonUniforms.background.value.copy(e.background)),this.compute(this.renderKernel,this.renderResultData,t),this.commonUniforms.renderResult.value=this.renderResultData.buffer.texture,this.renderer.render(this.renderScene,t),this.commonUniforms.frame.value++},t.prototype.resetFrame=function(){this.commonUniforms.frame.value=0},t}(o),l=function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),m=function(e){function t(t){(t=t||{}).fragmentShader=t.fragmentShader||"#define GLSLIFY 1\nuniform float renderType;\nuniform vec3 albedo;\nuniform vec3 emission;\nuniform float roughness;\nuniform float metalness;\nuniform mat3 normalMatrix;\n\nuniform sampler2D albedoMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metalnessMap;\nuniform sampler2D normalMap;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDepth;\nvarying vec4 vPos;\nvarying vec3 vViewPosition;\n\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See vec4(0.6,0.6,0.5333333333333333,0.5333333333333333)\n\n\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\tvec2 st0 = dFdx( vUv.st );\n\tvec2 st1 = dFdy( vUv.st );\n\n\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\tvec3 N = normalize( surf_norm );\n\n\tmat3 tsn = mat3( S, T, N );\n\n\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\treturn normalize( tsn * mapN );\n\n}\n\nvoid main( void ) {\n\n\tif( renderType == 0.0 ) {\n\n\t\t//albedo\t\t\n\t\t#ifdef USE_ALBEDOMAP\n\n\t\t\tgl_FragColor = texture2D( albedoMap, vUv );\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor = vec4( albedo, 0.0 );\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 1.0 ) {\n\n\t\t//emission\n\t\tgl_FragColor = vec4( emission, 0.0 );\n\t\t\n\t} else if ( renderType == 2.0 ) {\n\n\t\t#ifdef USE_ROUGHNESSMAP\n\n\t\t\tgl_FragColor.y = texture2D( roughnessMap, vUv ).y * roughness;\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor.y = roughness;\n\t\t\t\n\t\t#endif\n\n\t\t#ifdef USE_METALNESSMAP\n\n\t\t\tgl_FragColor.z = texture2D( metalnessMap, vUv ).z * metalness;\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor.z = metalness;\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 3.0 || renderType == 5.0 ) {\n\n\t\t//normal\n\n\t\t#ifdef USE_NORMALMAP\n\t\t\tvec3 normal = vNormal; \n\t\t\tnormal = normalize( normalMatrix * normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= 1.0;\n\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t\t\tgl_FragColor = vec4( normal * 0.5 + 0.5 , 0.0 );\n\n\t\t#else\n\t\t\n\t\t\tgl_FragColor = vec4( vNormal * 0.5 + 0.5, 0.0 );\n\t\t\t\n\t\t#endif\n\t\t\n\t} else if ( renderType == 4.0 || renderType == 6.0 ) {\n\n\t\t//depth\n\t\t// gl_FragColor = vec4( vec3( ( ( vPos.z / vPos.w ) + 1.0 ) / 2.0 ), vPos.w  );\n\t\tgl_FragColor = vec4( vec3( vPos.z ), vPos.w  );\n\t\t\n\t}\n\n\t\n}",t.vertexShader=t.vertexShader||"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDepth;\nvarying vec4 vPos;\nvarying vec3 vViewPosition;\n\nvoid main( void ) {\n\n\tvec3 pos = position;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\tvUv = uv;\n\tvNormal = normal;\n\tvPos = gl_Position;\n\tvViewPosition = - mvPosition.xyz;\n\n}",t.uniforms=t.uniforms||{},t.uniforms.renderType&&console.warn('"renderType" uniform cannnot be used.'),t.uniforms.renderType={value:0};var n=t.baseMaterial&&null==t.baseMaterial.length&&t.baseMaterial,r=t.albedoMap||n&&n.map,o=t.roughnessMap||n&&n.roughnessMap,a=t.metalnessMap||n&&n.metalnessMap,s=t.normalMap||n&&n.normalMap,l=t.emissionMap&&n&&n.emissiveMap;return t.defines={USE_ALBEDOMAP:null!=r&&null==t.albedo,USE_ROUGHNESSMAP:null!=o&&null==t.roughness,USE_METALNESSMAP:null!=a&&null==t.metalness,USE_NORMALMAP:null!=s,USE_EMISSIONMAP:null!=l&&null==t.emission},t.uniforms.albedo={value:t.albedo||(n?n.color:new i.Vector3(0,0,0))},t.uniforms.emission={value:t.emission||(n?n.emissive:new i.Vector3(0,0,0))},t.uniforms.roughness={value:t.roughness||(n?n.roughness:0)},t.uniforms.metalness={value:t.metalness||(n?n.metalness:0)},t.uniforms.albedoMap={value:r},t.uniforms.emissionMap={value:l},t.uniforms.roughnessMap={value:o},t.uniforms.metalnessMap={value:a},t.uniforms.normalMap={value:s},t.extensions?t.extensions.derivatives=!0:t.extensions={derivatives:!0},delete t.baseMaterial,delete t.albedo,delete t.roughness,delete t.metalness,delete t.emission,delete t.albedoMap,delete t.roughnessMap,delete t.metalnessMap,delete t.emissionMap,e.call(this,t)||this}return l(t,e),Object.defineProperty(t.prototype,"albedo",{set:function(e){this.uniforms.albedo.value.copy(e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"emission",{set:function(e){this.uniforms.emission.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"roughness",{set:function(e){this.uniforms.roughness.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"metalness",{set:function(e){this.uniforms.metalness.value=e},enumerable:!1,configurable:!0}),t.prototype.setRenderType=function(e){this.uniforms.renderType.value=e,this.side=e>=5?i.BackSide:i.FrontSide},Object.defineProperty(t.prototype,"isOrayTracingMaterial",{get:function(){return!0},enumerable:!1,configurable:!0}),t}(i.ShaderMaterial)}])}));