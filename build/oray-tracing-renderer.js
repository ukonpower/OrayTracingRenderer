!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],t):"object"==typeof exports?exports.OrayTracingRenderer=t(require("THREE")):e.OrayTracingRenderer=t(e.THREE)}(window,(function(e){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=8)}([function(t,r){t.exports=e},function(e,t){e.exports="uniform vec2 dataSize;\r\nuniform mat4 cameraMatrixWorld;\r\nuniform mat4 cameraMatrixWorldInverse;\r\nuniform mat4 cameraProjectionMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform mat4 projectionMatrix;\r\n\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform vec3 albedo;\r\n\r\nuniform float time;\r\nuniform float frame;\r\n\r\nuniform sampler2D backBuffer;\r\nuniform sampler2D albedoBuffer;\r\nuniform sampler2D emissionBuffer;\r\nuniform sampler2D materialBuffer;\r\nuniform sampler2D normalBuffer;\r\nuniform sampler2D depthBuffer;\r\nuniform sampler2D backNormalBuffer;\r\nuniform sampler2D backDepthBuffer;\r\nuniform samplerCube envMap;\r\n\r\nbool debug = false;\r\nvarying vec2 vUv;\r\n\r\n#define MAX_BOUNCE 8\r\n\r\n#define PI 3.14159265359\n#define TPI 6.28318530718\n#define HPI 1.57079632679\n\r\n\nfloat random(vec2 p){\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\r\n\r\nconst float INF = 1e+10;\r\nconst float EPS = 1e-5;\r\n\r\nstruct Ray {\r\n\tvec3 origin;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct Material {\r\n\tvec3 albedo;\r\n\tvec3 emission;\r\n\tfloat roughness;\r\n\tfloat metalness;\r\n};\r\n\r\nstruct Intersection {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tvec3 nextPosition;\r\n\tbool hit;\r\n\tfloat distance;\r\n\tMaterial material;\r\n};\r\n\r\nstruct Sphere {\r\n\tvec3 position;\r\n\tfloat radius;\r\n\tMaterial material;\r\n};\r\n\r\nstruct Plane {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tMaterial material;\r\n};\r\n\r\nvec3 random3D( vec2 p, float seed ) {\r\n\r\n\treturn vec3(\r\n\t\trandom( p + seed ),\r\n\t\trandom( p + seed + 100.0 ),\r\n\t\trandom( p + seed + 303.2)\r\n\t);\r\n\t\r\n}\r\n\r\n//http://project-asura.com/blog/archives/3124\r\nvec3 ggx( Intersection intersection, Ray ray, vec2 noise )\r\n{\r\n\r\n\tvec3 normal = intersection.normal;\r\n\tfloat roughness = intersection.material.roughness;\r\n\r\n    float a = roughness * roughness;\r\n\r\n    float phi = 2.0 * PI * noise.x;\r\n    float cosTheta = sqrt( ( 1.0  - noise.y ) / ( 1.0  + ( a * a - 1.0 ) * noise.y ) );\r\n    float sinTheta = sqrt( 1.0  - cosTheta * cosTheta );\r\n    \r\n    vec3 H;\r\n    H.x = sinTheta * cos( phi );\r\n    H.y = sinTheta * sin( phi );\r\n    H.z = cosTheta;\r\n    \r\n    vec3 upVector = abs( normal.z ) < 0.999 ? vec3( 0, 0, 1 ) : vec3( 1, 0, 0 );\r\n    vec3 tangentX = normalize( cross( upVector , normal ) );\r\n    vec3 tangentY = cross( normal, tangentX );\r\n\r\n    return reflect( ray.direction, tangentX * H.x + tangentY * H.y + normal * H.z );\r\n\r\n}\r\n\r\nvec3 diffuse( Intersection intersection, vec2 noise ) {\r\n\r\n\tvec3 normal = intersection.normal;\r\n\t\r\n\tfloat r = sqrt( noise.x );\r\n\tfloat theta = TPI * noise.y;\r\n\r\n\tvec3 tDir = vec3( r * cos( theta ), r * sin( theta ), sqrt( 1.0 - noise.x ) );\r\n\tvec3 tangent = normalize( cross( normal, abs( normal.x ) > EPS ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ) ) );\r\n\tvec3 binormal = cross( tangent, normal );\r\n\t\r\n\treturn tangent * tDir.x + binormal * tDir.y + normal * tDir.z;\r\n\r\n}\r\n\r\n#define MAX_STEP 100\r\n\r\nbool checkIntersect( inout vec3 startPos, inout vec3 nextPos ) {\r\n\r\n\treturn false;\r\n\t\r\n}\r\n\r\nvec3 getScreenPos( vec3 p ) {\r\n\r\n\tvec4 clip = cameraProjectionMatrix * vec4( p, 1.0 );\r\n\treturn ( clip / clip.w ).xyz;\r\n\r\n}\r\n\r\nint shootRay( inout Intersection intersection, inout Ray ray, int bounce ) {\r\n\r\n\tintersection.hit = false;\r\n\tintersection.distance = INF;\r\n\tintersection.position = ray.origin;\r\n\r\n\tfor( int i = 0; i < MAX_STEP; i++ ) {\r\n\t\t\r\n\t\tintersection.nextPosition = intersection.position + ray.direction * 0.5;\r\n\t\tvec3 startPosClip;\r\n\t\tvec3 nextPosClip;\r\n\t\tvec2 nextPosUV;\r\n\t\tvec4 texDepthFront;\r\n\t\tvec4 texDepthBack;\r\n\t\tfloat texDepthFrontClip;\r\n\t\tfloat texDepthBackClip;\r\n\r\n\t\tfor( int j = 0; j < 1; j ++ ) {\r\n\r\n\t\t\tstartPosClip = getScreenPos( intersection.position );\r\n\t\t\tnextPosClip = getScreenPos( intersection.nextPosition );\r\n\t\t\t\r\n\t\t\tnextPosUV = nextPosClip.xy * 0.5 + 0.5;\r\n\r\n\t\t\ttexDepthFront = texture2D( depthBuffer, nextPosUV );\r\n\t\t\ttexDepthFrontClip = texDepthFront.x / texDepthFront.w;\r\n\r\n\t\t\ttexDepthBack = texture2D( backDepthBuffer, nextPosUV );\r\n\t\t\ttexDepthBackClip = texDepthBack.x / texDepthBack.w;\r\n\r\n\t\t\tif(\r\n\t\t\t\t( nextPosClip.z >= texDepthFrontClip && startPosClip.z <= texDepthBackClip ) && texDepthFrontClip != 0.0 \r\n\t\t\t) {\r\n\r\n\t\t\t\tintersection.hit = true;\r\n\t\t\t\tintersection.nextPosition = ( intersection.position + intersection.nextPosition ) / 2.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif( j == 0 ) {\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvec3 nextPos = intersection.nextPosition + ( intersection.nextPosition - intersection.position ) / 2.0;\r\n\t\t\t\t\tintersection.position = intersection.nextPosition;\r\n\t\t\t\t\tintersection.nextPosition = nextPos;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\r\n\t\tif( intersection.hit ) {\r\n\r\n\t\t\tMaterial mat;\r\n\t\t\tmat.albedo = texture2D( albedoBuffer, nextPosUV ).xyz;\r\n\t\t\tmat.emission = texture2D( emissionBuffer, nextPosUV ).xyz;\r\n\t\t\t\r\n\t\t\tvec4 rmTex = texture2D( materialBuffer, nextPosUV );\r\n\t\t\tmat.roughness = rmTex.y;\r\n\t\t\tmat.metalness = rmTex.z;\r\n\t\t\tintersection.material = mat;\r\n\t\t\tintersection.normal = normalize( texture2D( normalBuffer, nextPosUV ).xyz * 2.0 - 1.0 );\r\n\t\t\tintersection.position = ( cameraProjectionMatrixInverse * vec4( (nextPosUV * 2.0 - 1.0) * texDepthFront.w, texDepthFrontClip, texDepthFront.w ) ).xyz;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tintersection.position = intersection.nextPosition;\r\n\r\n\t}\r\n\r\n\r\n\tif( intersection.hit ) {\r\n\r\n\t\tfloat seed =  frame * 0.001 + float( bounce );\r\n\t\tvec2 noise = vec2( random( vUv + sin( seed ) ), random( vUv - cos( seed ) ) );\r\n\r\n\t\tray.origin = intersection.position;\r\n\r\n\t\tif( random( vUv * 10.0 + sin( time + float( frame ) + seed ) ) > 0.5 * ( 1.0 - intersection.material.roughness * ( 1.0 - intersection.material.metalness )  ) + intersection.material.metalness * 0.5 ) {\r\n\t\t\t\r\n\t\t\tray.direction = diffuse( intersection, noise );\r\n\t\t\t\r\n\t\t\treturn 0;\r\n\t\t\t\r\n\t\t} else {\r\n\r\n\t\t\tray.direction = ggx( intersection, ray, noise );\r\n\t\t\treturn 1;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tvec4 rayDir = vec4( ray.direction, 1.0 ) * cameraMatrixWorldInverse;\r\n\t\tintersection.material.emission = textureCube( envMap, rayDir.xyz, 0.0 ).xyz * 2.5;\r\n\r\n\t}\r\n\r\n\treturn 0;\r\n\r\n}\r\n\r\nvec3 radiance( inout Ray ray ) {\r\n\r\n\tIntersection intersection;\r\n\r\n\tfloat memMetalness[MAX_BOUNCE];\r\n\tvec3 memAlbedo[MAX_BOUNCE];\r\n\tvec3 memEmission[MAX_BOUNCE];\r\n\tint memDir[MAX_BOUNCE];\r\n\r\n\tint bounce;\r\n\t\r\n\tfor ( int i = 0; i < MAX_BOUNCE; i++ ) {\r\n\r\n\t\tmemDir[i] = shootRay( intersection, ray, i );\r\n\t\tmemAlbedo[i] = intersection.material.albedo;\r\n\t\tmemEmission[i] = intersection.material.emission;\r\n\t\tmemMetalness[i] = intersection.material.metalness;\r\n\r\n\t\tif( !intersection.hit ) {\r\n\r\n\t\t\tbounce = i;\r\n\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tvec3 emission = memEmission[ MAX_BOUNCE - 1 ];\r\n\tvec3 col;\r\n\r\n\tfor ( int i = MAX_BOUNCE -1; i >= 0 ; i-- ) {\r\n\r\n\t\tif ( memDir[ i ] > 0 ) {\r\n\r\n\t\t\t//ggx\r\n\t\t\tcol *= mix( vec3( 1.0 ), memAlbedo[i], memMetalness[ i ] );\r\n\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t//diffuse\r\n\t\t\tcol *= mix( vec3( 0.0 ), memAlbedo[i], 1.0 - memMetalness[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tcol += memEmission[ i ];\r\n\r\n\t}\r\n\r\n\treturn col;\r\n\t\r\n\t\r\n}\r\n\r\nvoid main( void ) {\r\n\t\r\n\tvec4 befTex = texture2D( backBuffer, vUv ) * min( frame, 1.0 ) ;\r\n\r\n\tRay ray;\r\n\t// ray.origin = cameraPosition;\r\n\t// ray.direction = ( cameraProjectionMatrixInverse * vec4( vUv * 2.0 - 1.0, 1.0, 1.0 ) ).xyz;\r\n\t\r\n\tray.origin = vec3( 0.0, 0.0, 0.0 );\r\n\tray.direction = ( cameraProjectionMatrixInverse * vec4( vUv * 2.0 - 1.0, 1.0, 1.0 ) ).xyz;\r\n\tray.direction.xy += vec2( random( vUv + time ) * 2.0 - 1.0 , random( vUv - time ) * 2.0 - 1.0 ) / max( dataSize.y,dataSize.x );\r\n\tray.direction = normalize( ray.direction );\r\n\r\n\tvec4 o = vec4( ( befTex.xyz + radiance( ray ) ) , 1.0 );\r\n\tgl_FragColor = o;\r\n\r\n\r\n}"},function(e,t){e.exports="varying vec2 vUv;\r\n\r\nvoid main( void ) {\r\n\r\n\tvec3 pos = position;\r\n\tgl_Position = vec4( pos, 1.0 );\r\n\r\n\tvUv = vec2( uv.x, uv.y );\r\n\r\n}"},function(e,t){e.exports="uniform float frame;\r\nuniform sampler2D renderResult;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main( void ) {\r\n\r\n\tvec3 color = texture2D( renderResult, vUv ).xyz;\r\n\tcolor /= (frame + 1.0);\r\n\r\n\tgl_FragColor = vec4( color, 1.0 );\r\n\r\n}"},function(e,t){e.exports="varying vec2 vUv;\n\nvoid main() {\n    gl_Position = vec4( position, 1.0 );\n    vUv = uv;\n}"},function(e,t){e.exports="uniform sampler2D tex;\nvarying vec2 vUv;\n\nvoid main() {\n    gl_FragColor = texture2D(tex,vUv);\n}"},function(e,t){e.exports="varying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying float vDepth;\r\nvarying vec4 vPos;\r\nvarying vec3 vViewPosition;\r\n\r\nvoid main( void ) {\r\n\r\n\tvec3 pos = position;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\tvUv = uv;\r\n\tvNormal = normal;\r\n\tvPos = gl_Position;\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n}"},function(e,t){e.exports="uniform float renderType;\r\nuniform vec3 albedo;\r\nuniform vec3 emission;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform mat3 normalMatrix;\r\n\r\nuniform sampler2D albedoMap;\r\nuniform sampler2D roughnessMap;\r\nuniform sampler2D metalnessMap;\r\nuniform sampler2D normalMap;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying float vDepth;\r\nvarying vec4 vPos;\r\nvarying vec3 vViewPosition;\r\n\r\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\r\n\r\n\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n\tvec2 st0 = dFdx( vUv.st );\r\n\tvec2 st1 = dFdy( vUv.st );\r\n\r\n\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\r\n\r\n\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\r\n\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\r\n\tvec3 N = normalize( surf_norm );\r\n\r\n\tmat3 tsn = mat3( S, T, N );\r\n\r\n\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n\r\n\treturn normalize( tsn * mapN );\r\n\r\n}\r\n\r\n\r\nvoid main( void ) {\r\n\r\n\tif( renderType == 0.0 ) {\r\n\r\n\t\t//albedo\t\t\r\n\t\t#ifdef USE_ALBEDOMAP\r\n\r\n\t\t\tgl_FragColor = texture2D( albedoMap, vUv );\r\n\r\n\t\t#else\r\n\t\t\r\n\t\t\tgl_FragColor = vec4( albedo, 0.0 );\r\n\t\t\t\r\n\t\t#endif\r\n\t\t\r\n\t} else if ( renderType == 1.0 ) {\r\n\r\n\t\t//emission\r\n\t\tgl_FragColor = vec4( emission, 0.0 );\r\n\t\t\r\n\t} else if ( renderType == 2.0 ) {\r\n\r\n\t\t#ifdef USE_ROUGHNESSMAP\r\n\r\n\t\t\tgl_FragColor.y = texture2D( roughnessMap, vUv ).y * roughness;\r\n\r\n\t\t#else\r\n\t\t\r\n\t\t\tgl_FragColor.y = roughness;\r\n\t\t\t\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_METALNESSMAP\r\n\r\n\t\t\tgl_FragColor.z = texture2D( metalnessMap, vUv ).z * metalness;\r\n\r\n\t\t#else\r\n\t\t\r\n\t\t\tgl_FragColor.z = metalness;\r\n\t\t\t\r\n\t\t#endif\r\n\t\t\r\n\t} else if ( renderType == 3.0 || renderType == 5.0 ) {\r\n\r\n\t\t//normal\r\n\r\n\t\t#ifdef USE_NORMALMAP\r\n\t\t\tvec3 normal = vNormal; \r\n\t\t\tnormal = normalize( normalMatrix * normal );\r\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n\t\t\tmapN.xy *= 1.0;\r\n\r\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\r\n\t\t\tgl_FragColor = vec4( normal * 0.5 + 0.5 , 0.0 );\r\n\r\n\t\t#else\r\n\t\t\r\n\t\t\tgl_FragColor = vec4( vNormal * 0.5 + 0.5, 0.0 );\r\n\t\t\t\r\n\t\t#endif\r\n\t\t\r\n\t} else if ( renderType == 4.0 || renderType == 6.0 ) {\r\n\r\n\t\t//depth\r\n\t\t// gl_FragColor = vec4( vec3( ( ( vPos.z / vPos.w ) + 1.0 ) / 2.0 ), vPos.w  );\r\n\t\tgl_FragColor = vec4( vec3( vPos.z ), vPos.w  );\r\n\t\t\r\n\t}\r\n\r\n\t\r\n}"},function(e,t,r){"use strict";r.r(t),r.d(t,"Renderer",(function(){return y})),r.d(t,"Material",(function(){return F}));var n,i=r(0),o=r(1),a=r.n(o),s=r(2),l=r.n(s),c=r(3),m=r.n(c),u=r(4),f=r.n(u),v=r(5),p=r.n(v),d=function(){function e(e,t){this.renderer=e,this.dataSize=t.clone(),this.uniforms={dataSize:{value:t.clone()}},this.tempDataLinear=this.createData({minFilter:i.LinearFilter,magFilter:i.LinearFilter}),this.tempDataNear=this.createData({minFilter:i.NearestFilter,magFilter:i.NearestFilter}),this.scene=new i.Scene,this.camera=new i.Camera,this.materials=[],this.mesh=new i.Mesh(new i.PlaneBufferGeometry(2,2)),this.scene.add(this.mesh)}return Object.defineProperty(e.prototype,"isSupported",{get:function(){return this.renderer.extensions.get("OES_texture_float")},enumerable:!1,configurable:!0}),e.prototype.createInitializeTexture=function(){var e=new Float32Array(this.uniforms.dataSize.value.x*this.uniforms.dataSize.value.y*4),t=new i.DataTexture(e,this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,i.RGBAFormat,i.FloatType);return t.needsUpdate=!0,t},e.prototype.createData=function(e,t){var r,n,o={wrapS:i.ClampToEdgeWrapping,wrapT:i.ClampToEdgeWrapping,minFilter:i.NearestFilter,magFilter:i.NearestFilter,format:i.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?i.HalfFloatType:i.FloatType,stencilBuffer:!1,depthBuffer:!1};e&&(e.isDataTexture?(r=e,t&&(n=t)):n=e),n&&(o.wrapS=n.wrapS||o.wrapS,o.wrapT=n.wrapT||o.wrapT,o.minFilter=n.minFilter||o.minFilter,o.magFilter=n.magFilter||o.magFilter,o.format=n.format||o.format,o.type=n.type||o.type,o.stencilBuffer=n.stencilBuffer||o.stencilBuffer,o.depthBuffer=n.depthBuffer||o.depthBuffer);var a={buffer:new i.WebGLRenderTarget(this.uniforms.dataSize.value.x,this.uniforms.dataSize.value.y,o)};if(r){var s=this.createKernel(p.a);s.uniforms.tex={value:r},this.compute(s,a)}return a},e.prototype.createKernel=function(e,t){var r=this.CopyUniforms({},t);r=this.CopyUniforms(r,this.uniforms);var n=new i.ShaderMaterial({vertexShader:f.a,fragmentShader:e,uniforms:r});return this.materials.push(n),{material:n,uniforms:r}},e.prototype.compute=function(e,t,r){var n;n=t.buffer.texture.magFilter==i.LinearFilter?this.tempDataLinear:this.tempDataNear,this.mesh.material=e.material;var o=this.renderer.getRenderTarget();this.renderer.setRenderTarget(n.buffer),this.renderer.render(this.scene,r||this.camera),this.swapBuffers(t,n),this.renderer.setRenderTarget(o)},e.prototype.swapBuffers=function(e,t){var r=e.buffer;e.buffer=t.buffer,t.buffer=r},e.prototype.dispose=function(){this.mesh.geometry.dispose();for(var e=0;e<this.materials.length;e++)this.materials[e].dispose();this.scene.remove(this.mesh),this.tempDataLinear.buffer.dispose(),this.tempDataNear.buffer.dispose()},e.prototype.CopyUniforms=function(e,t){if(!e||!t)return e||t;for(var r=Object.keys(t),n=0;n<r.length;n++)e[r[n]]||(e[r[n]]=t[r[n]]);return e},e}(),h=(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),y=function(e){function t(t,r){var n=this,o=r.clone();return(n=e.call(this,t,o)||this).commonUniforms={backBuffer:{value:null},albedoBuffer:{value:null},emissionBuffer:{value:null},materialBuffer:{value:null},normalBuffer:{value:null},depthBuffer:{value:null},backNormalBuffer:{value:null},backDepthBuffer:{value:null},renderResult:{value:null},cameraMatrixWorld:{value:null},cameraMatrixWorldInverse:{value:null},cameraProjectionMatrixInverse:{value:null},cameraProjectionMatrix:{value:null},envMap:{value:null},background:{value:new i.Vector3(1,1,1)},frame:{value:0}},n.init(),n}return h(t,e),t.prototype.init=function(){this.renderKernel=this.createKernel(a.a,this.commonUniforms),this.renderResultData=this.createData(),this.orayRenderTargets={albedo:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),emission:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.HalfFloatType}),material:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter}),normal:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),depth:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backNormal:new i.WebGLRenderTarget(1*this.dataSize.x,1*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType}),backDepth:new i.WebGLRenderTarget(2*this.dataSize.x,2*this.dataSize.y,{magFilter:i.NearestFilter,minFilter:i.NearestFilter,type:i.FloatType})},this.renderScene=new i.Scene,this.screen=new i.Mesh(new i.PlaneBufferGeometry(2,2),new i.ShaderMaterial({vertexShader:l.a,fragmentShader:m.a,uniforms:this.commonUniforms})),this.renderScene.add(this.screen)},t.prototype.render=function(e,t){var r=this.renderer.getRenderTarget();if(0==this.commonUniforms.frame.value){var n=e.background;e.background=null;for(var i=Object.keys(this.orayRenderTargets),o=function(r){e.traverse((function(e){e.isMesh&&e.material.isMaterial&&e.material.setRenderType(r)})),a.renderer.setRenderTarget(a.orayRenderTargets[i[r]]),a.renderer.render(e,t),a.commonUniforms[i[r]+"Buffer"].value=a.orayRenderTargets[i[r]].texture},a=this,s=0;s<i.length;s++)o(s);e.background=n}this.renderer.setRenderTarget(r),this.commonUniforms.backBuffer.value=this.renderResultData.buffer.texture,this.commonUniforms.cameraMatrixWorld.value=t.matrixWorld,this.commonUniforms.cameraMatrixWorldInverse.value=t.matrixWorldInverse,this.commonUniforms.cameraProjectionMatrix.value=t.projectionMatrix,this.commonUniforms.cameraProjectionMatrixInverse.value=t.projectionMatrixInverse,e.background&&(e.background.isTexture?this.commonUniforms.envMap.value=e.background:this.commonUniforms.background.value.copy(e.background)),this.compute(this.renderKernel,this.renderResultData,t),this.commonUniforms.renderResult.value=this.renderResultData.buffer.texture,this.renderer.render(this.renderScene,t),this.commonUniforms.frame.value++},t.prototype.resetFrame=function(){this.commonUniforms.frame.value=0},t}(d),g=r(6),x=r.n(g),b=r(7),M=r.n(b),P=function(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(t,r)};return function(t,r){function n(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}}(),F=function(e){function t(t){(t=t||{}).fragmentShader=t.fragmentShader||M.a,t.vertexShader=t.vertexShader||x.a,t.uniforms=t.uniforms||{},t.uniforms.renderType&&console.warn('"renderType" uniform cannnot be used.'),t.uniforms.renderType={value:0};var r=t.baseMaterial&&null==t.baseMaterial.length&&t.baseMaterial,n=t.albedoMap||r&&r.map,o=t.roughnessMap||r&&r.roughnessMap,a=t.metalnessMap||r&&r.metalnessMap,s=t.normalMap||r&&r.normalMap,l=t.emissionMap&&r&&r.emissiveMap;return t.defines={USE_ALBEDOMAP:null!=n&&null==t.albedo,USE_ROUGHNESSMAP:null!=o&&null==t.roughness,USE_METALNESSMAP:null!=a&&null==t.metalness,USE_NORMALMAP:null!=s,USE_EMISSIONMAP:null!=l&&null==t.emission},t.uniforms.albedo={value:t.albedo||(r?r.color:new i.Vector3(0,0,0))},t.uniforms.emission={value:t.emission||(r?r.emissive:new i.Vector3(0,0,0))},t.uniforms.roughness={value:t.roughness||(r?r.roughness:0)},t.uniforms.metalness={value:t.metalness||(r?r.metalness:0)},t.uniforms.albedoMap={value:n},t.uniforms.emissionMap={value:l},t.uniforms.roughnessMap={value:o},t.uniforms.metalnessMap={value:a},t.uniforms.normalMap={value:s},t.extensions?t.extensions.derivatives=!0:t.extensions={derivatives:!0},delete t.baseMaterial,delete t.albedo,delete t.roughness,delete t.metalness,delete t.emission,delete t.albedoMap,delete t.roughnessMap,delete t.metalnessMap,delete t.emissionMap,e.call(this,t)||this}return P(t,e),Object.defineProperty(t.prototype,"albedo",{set:function(e){this.uniforms.albedo.value.copy(e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"emission",{set:function(e){this.uniforms.emission.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"roughness",{set:function(e){this.uniforms.roughness.value=e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"metalness",{set:function(e){this.uniforms.metalness.value=e},enumerable:!1,configurable:!0}),t.prototype.setRenderType=function(e){this.uniforms.renderType.value=e,this.side=e>=5?i.BackSide:i.FrontSide},Object.defineProperty(t.prototype,"isOrayTracingMaterial",{get:function(){return!0},enumerable:!1,configurable:!0}),t}(i.ShaderMaterial)}])}));